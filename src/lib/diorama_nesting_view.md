# Backbone.Diorama.NestingView

A common pattern for Backbone applications is to nest views inside each
other. For example a collection index view where each model in the
collection gets a sub view. The advantage of this approach is that each
sub view can listen for and respond to events about a particular model,
removing the need for the collection view to be re-rendered.

Backbone.Diorama.NestingView makes it easy to stack views, as seen in
this example PostIndexView

```coffee
class Backbone.Views.PostIndexView extends Backbone.Diorama.NestingView
  template: Handlebars.templates['post_index.hbs']

  initialize: (options) ->
    @postCollection = options.postCollection # A Backbone.Collection
    @render()

  render: =>
    # Render template, creating subviews with addSubViewTo helper (see template below)
    @$el.html(@template(thisView: @, posts: @postCollection.models))
    # Attach the subviews to the elements created by subView helper in the template
    @attachSubViews()

    return @

  onClose: ->
    @closeSubViews()
```

```hbs
### post_index_view template ###
<h1>PostIndex</h1>
{{#each posts}}
  <!-- Create a PostRowView for each post, and add it to the template with subView -->
  {{addSubViewTo ../thisView "PostRowView" model=this}}
{{/each}}
```

## Handlebars helpers

#### {{ addSubViewTo nestingView childViewName (cache-key-template) (optionsHash) }}
Call this helper to insert a sub view into a template at this point. Creates an
instance of the given childViewName, adds it to nestingView.subViews and
inserts a placeholder DOM element. 

* ```nestingView``` - The parent nesting view object, typically the view whose template is being generated. If you used a generator to create your nesting view, this will be passed into the template as ```thisView```
* ```childViewName``` - The class name of the child view you want to insert. This will expect the view to be namespaced in Backbone.Views, e.g. given 'PostRowView', it create an instance of Backbone.View.PostRowView
* ```cache-key-template``` - (optional) A optional handlebars template you can use to uniquely indentify your sub view, which allows view reuse and the ability to render a parent view without re-rendering its children. See [Caching sub views](#caching-sub-views)
* ```optionsHash``` - (optional) A hash which will be passed into the constructor for the view named by childViewName. If only 3 arguments are given, this is assumed to be the 3rd argument (slightly odd behavior forced by handlebars :-| ).

Examples:

```hbs
  <!-- Add a new Backbone.Views.PostRowView for the post model into the current NestingView -->
  {{addSubViewTo thisView "PostRowView" model=post}} 
``` 

```hbs
  <!-- Add a new Backbone.Views.PostRowView for the post model into the current NestingView -->
  {{addSubViewTo thisView "PostRowView" model=post}} 
``` 

## Backbone.Diorama.NestingView methods

#### attachSubViews
For each view in ```@subViews```, it sets the DOM element of the view to the
placeholder rendered by the ```addSubViewTo``` handlebars helper. Call this
after you've rendered the template for your NestingView (NestingViews generated
by ```diorama generate nestingView``` do this by default).

#### closeSubViews
Calls ```close``` on each sub view. Call this inside your NestingView's onClose
method (NestingViews generated by ```diorama generate nestingView``` do this by
default).

#### renderSubViews
Calls render on each sub view. Sub-views generated by ```diorama generate
nestingView``` call render inside their initialize functions, meaning there is
no need to call this.

## Sub-view caching
By default, each time `parentView.attachSubViews()` is called, all existing subviews are closed and replaced with new ones. If you want to re-use sub views across attachSubView calls, specify 
