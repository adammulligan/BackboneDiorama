# Backbone.Diorama.NestingView

Backbone.Diorama.NestingView allows you to nest views inside each other, for
example a collection index view where each model in the collection gets a sub
view. This approach has a number of advantages:

* You can build smaller views and templates with clear responsibilities. ([SRP](http://en.wikipedia.org/wiki/Single_responsibility_principle)).
* Smaller views listen and respond to events on a smaller number of objects, meaning smaller parts of the DOM can be re-rendered when changes occur.
* Sub views create opportunities for code re-use ([DRY](http://en.wikipedia.org/wiki/Don't_repeat_yourself))
* Smaller views are easier to test in isolation.

## A quick example tutorial
Backbone.Diorama.NestingView makes it easy to stack views, as we'll see in this
example. Here we're making a index list of blog posts, where each blog post has
it's own view. Note that this code is very close to what is generated by
```diorama generate nestingView```

First, we create a new View extending from the Backbone.Diorama.NestingView
class, which itself extends from Backbone.View:

```coffee
class Backbone.Views.PostIndexView extends Backbone.Diorama.NestingView
  template: Handlebars.templates['post_index.hbs']

  initialize: (options) ->
    # Our Backone.Collection of posts
    @postCollection = options.postCollection 
    @render()

  render: =>
    # Render template, which will create subviews with addSubViewTo helper (see template below)
    # Note that a reference to @ is passed in as 'thisView'
    @$el.html(@template(thisView: @, posts: @postCollection.models))

    # Attach the subviews to the elements created by addSubViewTo helper
    @attachSubViews()

    return @

  onClose: ->
    # When we close this view, we also want to close all its child views
    @closeSubViews()
```

Next we need to create a template which uses the addSubViewTo handlebars helper
to create the sub views and render placeholder elements (complete with
data-sub-view-key attributes)

```html
### post_index_view template ###
<h1>My Blog posts</h1>
{{#each posts}}
  <!-- Use addSubViewTo to create a PostRowView for each post -->
  <!-- Note that the first argument is the nesting view we're attaching to -->
  {{addSubViewTo ../thisView "PostRowView" post=this}}
{{/each}}
```

Finally, we need to create the child view 'PostRowView'. This is just a typical
Backbone.View, which takes in post model and calls render() in its initialize
function.

```coffee
class Backbone.Views.PostRowView extends Backbone.View
  template: Handlebars.templates['post_row.hbs']

  initialize: (options) ->
    # Read in the post model send from the addSubViewTo handlebars helper
    @post = options.post
    # Call render as soon as the view is created
    @render()

  render: =>
    @$el.html(@template(post: @post.toJSON()))
```

...and the post row template, which shows the title of the post

```html
<h2>{{post.title}}</h2>
```

## Handlebars helpers

#### {{ addSubViewTo nestingView childViewName (cache-key-template) (optionsHash) }}
Call this helper to insert a sub view into a template at this point. Creates an
instance of the given childViewName, adds it to nestingView.subViews and
inserts a placeholder DOM element. 

* ```nestingView``` - The parent nesting view object, typically the view whose template is being generated. If you used a generator to create your nesting view, this will be passed into the template as ```thisView```
* ```childViewName``` - The class name of the child view you want to insert. This will expect the view to be namespaced in Backbone.Views, e.g. given 'PostRowView', it create an instance of Backbone.View.PostRowView
* ```cache-key-template``` - (optional) A optional handlebars template you can use to uniquely indentify your sub view, which allows view reuse and the ability to render a parent view without re-rendering its children. See [Caching sub views](#caching-sub-views)
* ```optionsHash``` - (optional) A hash which will be passed into the constructor for the view named by childViewName. If only 3 arguments are given, this is assumed to be the 3rd argument (slightly odd behavior forced by handlebars :-| ).

Examples:

```html
  <!-- Add a new Backbone.Views.PostRowView for the post model into the current NestingView -->
  {{addSubViewTo thisView "PostRowView" model=post}} 
``` 

```html
  <!-- Add a new Backbone.Views.PostRowView for the post model into the current NestingView -->
  {{addSubViewTo thisView "PostRowView" model=post}} 
``` 

## Backbone.Diorama.NestingView methods

#### attachSubViews
For each view in ```@subViews```, it sets the DOM element of the view to the
placeholder rendered by the ```addSubViewTo``` handlebars helper. Call this
after you've rendered the template for your NestingView (NestingViews generated
by ```diorama generate nestingView``` do this by default).

#### closeSubViews
Calls ```close``` on each sub view. Call this inside your NestingView's onClose
method (NestingViews generated by ```diorama generate nestingView``` do this by
default).

#### renderSubViews
Calls render on each sub view. Sub-views generated by ```diorama generate
nestingView``` call render inside their initialize functions, meaning there is
no need to call this.

## Sub-view caching
By default, each time `parentView.attachSubViews()` is called, all existing subviews are closed and replaced with new ones. If you want to re-use sub views across attachSubView calls, specify 
